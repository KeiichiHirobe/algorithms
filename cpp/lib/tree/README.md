## セグメント木
https://algo-logic.info/segment-tree/
に詳しい。

バリエーションとして、

* 更新方法
    * 一点上書き
    * 一点加算
    * 区間上書き
    * 区間加算

* 知りたい結果
    * 区間の最小値
    * 区間の最大値
    * 区間の合計
    * 区間の最大公約数(単位元0)

この中で、更新方法が一点のものについては遅延性は不要であるが、全て遅延で実装してしまった方が見通しが良いので全て遅延で実装している。
一点の更新に必要な条件(モノイド)より区間の更新に必要な条件(作用付きモノイド)の方が強いが、一点更新のみであれば葉でのみの更新となり、lazyは実質使われることはないため、問題ない。

区間の合計が知りたい場合には区間の長さに応じて、追加の考慮が必要になる。


遅延を理解するヒントメモ

* 更新の時、根から降りていき、木の区間が`[a,b)`に完全に含まれている時のみ降下を止める。子孫は未更新だが、同様に`[a,b)`に完全に含まれている。
* ^からわかるように、**lazyの要素は常に区間全体に均等に作用する**。
* 親は降下をやめて戻る時に即時更新される。この時、どこが更新されたのかなど考えず、単純に子の二つの区間をmergeすることだけ考えてればいい。


`SegTree<X,M>(n,fxx,fxm,fmm,ex,em,fml=[](M m,long long size)->M{return m;})`

* X
    * 知りたい結果の型
    * `data`に保存する型となる
    * 単位元が`ex`
    * なお、**`data`の初期値は`ex`である。ex以外にしたい場合はset/buildを呼ぶこと**
* M
    * 更新するときの型
    * `lazy`に保存する型となる
    * 単位元が`em`
* n 
    * 要素数
* fxx
    * `function<X(X, X)>`
    * 複数区間をmergeするときの関数
    * 知りたい結果が最小値なら`[](X x1, X x2) -> X { return min(x1, x2); }`
    * 知りたい結果が合計なら`[](X x1, X x2) -> X { return x1+x2; }`
* fxm
    * `function<X(X, M)>`
    * 区間に対して、更新を反映させるときの関数 
    * なお、更新を反映させるときは区間の全ての要素に均等に同じ更新を行うことが保証されていることに注意
    * 上書きの時は、`[](X x, M m) -> X { return m; }`
    * 加算の時は、`[](X x, M m) -> X { return x+m; }`
    * ^の例として、「区間加算で更新して、最小値を求めたいとき」「区間加算で更新して、合計を求めたいとき」がある。後者の場合は`m`が長さ考慮済みであることが必要
* fmm
    * `function<M(M, M)>`
    * 遅延列をmergeするときの関数
    * 上書きの時は、`[](M m1, M m2) -> X { return m2; }`
    * 加算の時は、`[](M m1, M m2) -> X { return m1+m2; }`
* fml
    * `function<M(M, int)>`
    * 長さを考慮して`data`を更新するためのもの
    * **updateの際に、fmm -> fml -> fxm と処理が走る**
    * 上書き、区間加算どちらの場合も求めたい結果が合計の場合は必要
    * 知りたい結果が合計なら`[](M m, long long size) -> X { return m * size; }`
