## 参考情報

### 部分和問題
典型
https://qiita.com/drken/items/a5e6fe22863b7992efdb#%E5%95%8F%E9%A1%8C-7%E5%80%8B%E6%95%B0%E5%88%B6%E9%99%90%E4%BB%98%E3%81%8D%E9%83%A8%E5%88%86%E5%92%8C%E5%95%8F%E9%A1%8C
https://github.com/drken1215/book_algorithm_solution/blob/master/solutions/chap05.md#56-%E5%80%8B%E6%95%B0%E5%88%B6%E9%99%90%E4%BB%98%E3%81%8D%E9%83%A8%E5%88%86%E5%92%8C%E5%95%8F%E9%A1%8C

部分和問題にさらに和に利用した数の制限が発生する。「Aのうち、l個の和をSの倍数にできるか」
https://atcoder.jp/contests/abc262/editorial/4503



### 部分和問題とナップザック問題の関係

ナップザック問題では、

`dp[i][w] = 最初のi個の品物{0,1,..i-1}までの中から重さがwを超えないように選んだ時の価値の最大値`
として、初期値0として求めることが多い。

個人的にはこれは少し難しい。

`dp[i][w] = 最初のi個の品物{0,1,..i-1}までの中から重さがwとなるように選んだ時の価値の最大値`
として、初期値-1、dp[0][0]=0とし、-1からはchmaxしないようにし、最後にdp[N][i]のmax値を取る。
部分和問題と全く同じように解ける。

配列の大きさは1e7くらいがギリギリの大きさであることに注意。
重複ありの場合に限り、実は部分和問題やナップサック問題はwの1次元配列で良い。

また、debug関連のオプションがあるとメモリallocateや実行がかなり遅くなるので遅い場合は外してみると良い